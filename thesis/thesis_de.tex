\documentclass[twoside,a4paper,fleqn,12pt]{article}
\usepackage{fancyhdr,a4wide,graphicx}
\usepackage[paper=a4paper,left=20mm,right=20mm,top=25mm,bottom=25mm]{geometry}
\usepackage{ngerman}
\pagestyle{fancy}
\usepackage[utf8]{inputenc}
\usepackage[]{amsfonts}
\usepackage{amsmath}
\usepackage{color}
\usepackage{colortbl}
\usepackage{mathptmx}
\usepackage[scaled=.90]{helvet}
\usepackage{courier}
\usepackage{verbatim}
\usepackage{sectsty}
\usepackage{listings}
\usepackage{scalefnt}
\usepackage{setspace}

\definecolor{darkred}{rgb}{.5,0,0}
\definecolor{darkblue}{rgb}{0,0,.5}
\usepackage[plainpages=false,pdfpagelabels,colorlinks=true,urlcolor=darkblue,pagecolor=darkred,citecolor=darkred,linkcolor=darkred]{hyperref}
%\newcommand\url[1]{\texttt{#1}}

\lstset{basicstyle=\ttfamily\small,lineskip=-0.5em}

% define the title
\author{Frank Richter 68278\\frank.richter@gmail.com}
\title{\usefont{OT1}{phv}{b}{n}\selectfont Entwicklung eines Compilers für eine auf Cg basierende Sprache zur Programmierung von Graphikkarten \normalfont}
\date{\today}

\begin{document}

\newcommand\btxandlong{und}
\newcommand\btxandshort{u}
\newcommand\Btxinlong{In}
\newcommand\Btxinshort{I}
\newcommand\btxpageslong{Seiten}
\newcommand\btxetalshort{et al}
\newcommand\btxeditionlong{Auflage}
\bibliographystyle{mystyle}

% Zeilenabstand 1.5
\renewcommand{\baselinestretch}{1.50}\normalsize

% Helvetoca für Section-Titel
\allsectionsfont{\usefont{OT1}{phv}{b}{n}\selectfont}

% Different font in captions
\newcommand{\captionstyle}{\small\centering}

\makeatletter  % Allow the use of @ in command names
\long\def\@makecaption#1#2{%
  \vskip\abovecaptionskip
  \sbox\@tempboxa{{\captionstyle #1: #2}}%
  \ifdim \wd\@tempboxa >\hsize
    {\captionstyle #1: #2\par}
  \else
    \hbox to\hsize{\hfil\box\@tempboxa\hfil}%
  \fi
  \vskip\belowcaptionskip}
\makeatother   % Cancel the effect of \makeatletter

% Fussnoten: alle Zeilen einrücken
\makeatletter
\newlength{\myFootnoteWidth}
\newlength{\myFootnoteLabel}
\setlength{\myFootnoteLabel}{1.2em}%  <-- can be changed to any valid value
\renewcommand{\@makefntext}[1]{%
  \setlength{\myFootnoteWidth}{\columnwidth}%
  \addtolength{\myFootnoteWidth}{-\myFootnoteLabel}%
  \noindent\makebox[\myFootnoteLabel][r]{\@makefnmark\ }%
  \parbox[t]{\myFootnoteWidth}{#1}%
}
\makeatother

% ---------- normal title ---------- %
\titlepage
\maketitle
\thispagestyle{empty}
\newpage
\thispagestyle{empty}
\mbox{}

% ---------- Fancyheader ---------- %
\fancyhead[L]{}
\fancyhead[R]{}
\fancyfoot[C]{\today}
\fancyfoot[R]{\footnotesize \thepage{}}
\renewcommand{\headrulewidth}{0pt}
\setlength{\headheight}{24pt}

% generates the title


% ---------- table of contents ---------- %
\newpage
\pagenumbering{roman}
%\addcontentsline{toc}{section}{Inhaltsverzeichnis}
\pdfbookmark[1]{Inhaltsverzeichnis}{myPDFtocLabel}
\tableofcontents

\cleardoublepage
\pagenumbering{arabic}
\newcommand\todo[1]{\footnote{\textcolor{red}{TODO: #1}}}
\newcommand\fcite[1]{\footnote{\cite{#1}}}
\newcommand\fciteX[2]{\footnote{\cite{#1}, #2}}

\section{Zielstellung}

In der Echtzeit-3D-Graphik werden für 3D-Objekte überwiegend Dreiecksnetze\footnote{engl. ``triangle mesh'' und kürzer ``mesh''; siehe z.B. \cite{watt_de}}
verwendet. Dies spiegelt sich in dem Aufbau von 3D-Graphikprozessoren~("`GPU"') wie auch
den Programmierschnittstellen~(\cite{glspec4}, \cite{dx10}) wieder. Insbesondere bei der Programmierung der GPU müssen
separate Vertex- und Fragmentprogramme % Ref oder Erklärung was Vertex/Fragment
erstellt werden. Diese Aufteilung sowie die Definition der "`Schnittstelle"' zwischen den Verarbeitungseinheiten muss vom Programmierer manuell vorgenommen werden.

Ziel dieser Arbeit ist es, einen Compiler zu entwickeln, der die Aufteilung in Vertex- und Fragmentprogramme (und auch Schnittstellendefinition)
automatisch vornimmt,
ohne dass der Programmierer explizit angeben muss, auf welcher der Funktionseinheiten ein bestimmter Befehl ausgeführt wird.
Die zu compilierende Sprache wird in Abschnitt~\ref{langspec} spezifiziert. Die Compilerimplementierung wird in Abschnitt~\ref{implementation}
beschrieben.

% Nochmal Abschnitt mit kurzer Beschreibung wichtiger Konzepte? (meshes, Vertices vs Fragmente, ...)

\section{Sprachspezifikation}
\label{langspec}

\input{langspec}

\section{Implementierung}
\label{implementation}

\subsection{Compiler-Aufbau}
\begin{figure}[h]
   \centering
  \includegraphics{compiler_structure}
  \caption{Schematischer Aufbau des Compilers}
  \label{fig:structure}
\end{figure}

Der Aufbau entspricht grösstenteils dem, was für einen Compiler üblich ist: das \emph{Front-End} generiert nach Syntax- und Semantikanalyse
eine Repräsentation des Programms in einem \emph{Zwischencode}. Auf dieser Zwischenrepräsentation werden im "`Middle-End"' % Ref wo das gesagt wird, oder besseres Wort
Optimierungen vorgenommen. Im letzten Schritt wird im \emph{Back-End} aus der optimierten Zwischenrepräsentation der tatsächliche Zielcode generiert.

Besonderheit dieses Compilers ist der Schritt \emph{Auftrennung VP/FP}. Hier wird für jeden Befehl der Zwischenrepräsentation untersucht, mit
welcher Berechnungsfrequenz~(siehe \ref{Berechnungsfrequenz})\footnote{Es wird auch "`Meshfrequenz"' definiert, aber der Einfachheit halber
trennt diese Implementierung bloß in Vertex- und Fragmentfrequenz. Das Konzept ist jedoch auch auf weitere Frequenzen erweiterbar.}
jeder Befehl des Programms ausgeführt werden muss - mit anderen Worten,
es wird untersucht, welche Befehle auf der Vertex-Einheit oder der Fragment-Einheit ausgeführt werden müssen. Mit diesen Informationen kann
das Programm entsprechend in ein Vertex- und ein Fragment-Programm aufgeteilt werden. Da zur Laufzeit auch ein "`Übergeben"' von Ausgaben
des Vertexprogramms an Eingaben des Fragmentprogramms stattfindet wird auch eine den Vertex-Ausgaben zu Fragment-Eingaben
abbildende "`Schnittstelle"' generiert.

Die Programme werden vom Aufspalter in Zwischencode ausgegeben und können noch einmal optimiert werden. % Irgendein besonderer Vorteil?
Abschließend werden ein Fragment- und ein Vertexprogramm im gewünschten Zielcode ausgegeben\footnote{Diese Implementierung benutzt den
gleichen Generator für beide Programme, prinzipiell könnten diese jedoch mit verschiedenen Generatoren ausgegeben werden.}.

%ein \emph{Lexer} spaltet die als Byte-Strom vorliegenden
%Quelldaten 

%\cite{wirth_compiler}

\section{Ausblick}

\cleardoublepage
\appendix
\bibliography{thesis_de}
\addcontentsline{toc}{section}{Literatur}

\end{document}
