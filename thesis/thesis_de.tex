\documentclass[twoside,a4paper,fleqn,12pt]{article}
\usepackage{fancyhdr,a4wide,graphicx}
\usepackage[paper=a4paper,left=20mm,right=20mm,top=25mm,bottom=25mm]{geometry}
\pagestyle{fancy}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
%\usepackage[]{amsfonts}
\usepackage{amsmath}
\usepackage{color}
\usepackage{colortbl}
%\usepackage{mathptmx}
\usepackage[bitstream-charter]{mathdesign}
\usepackage{charter}
\usepackage{helvet}
\usepackage{courier}
\usepackage{verbatim}
\usepackage{sectsty}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{scalefnt}
\usepackage{setspace}
\usepackage{ngerman}

\definecolor{darkred}{rgb}{.5,0,0}
\definecolor{darkblue}{rgb}{0,0,.5}
\usepackage[plainpages=false,pdfpagelabels,colorlinks=true,urlcolor=darkblue,pagecolor=darkred,citecolor=darkred,linkcolor=darkred]{hyperref}
%\newcommand\url[1]{\texttt{#1}}

\lstset{basicstyle=\ttfamily\small,lineskip=-0.5em,inputencoding=utf8/latin1}

% define the title
\author{Frank Richter 68278\\frank.richter@gmail.com}
\title{\usefont{OT1}{phv}{b}{n}\selectfont Entwicklung eines Compilers für eine auf Cg basierende Sprache zur Programmierung von Graphikkarten \normalfont}
\date{\today}

\begin{document}

\sloppy

\newcommand\btxandlong{und}
\newcommand\btxandshort{u}
\newcommand\Btxinlong{In}
\newcommand\Btxinshort{I}
\newcommand\btxpageslong{Seiten}
\newcommand\btxetalshort{et al}
\newcommand\btxeditionlong{Auflage}
\bibliographystyle{mystyle}

% Zeilenabstand 1.5
\renewcommand{\baselinestretch}{1.50}\normalsize

% Helvetica für Section-Titel
\allsectionsfont{\usefont{OT1}{phv}{b}{n}\selectfont}

% Different font in captions
\newcommand{\captionstyle}{\small\centering}

\makeatletter  % Allow the use of @ in command names
\long\def\@makecaption#1#2{%
  \vskip\abovecaptionskip
  \sbox\@tempboxa{{\captionstyle #1: #2}}%
  \ifdim \wd\@tempboxa >\hsize
    {\captionstyle #1: #2\par}
  \else
    \hbox to\hsize{\hfil\box\@tempboxa\hfil}%
  \fi
  \vskip\belowcaptionskip}
\makeatother   % Cancel the effect of \makeatletter

% Fussnoten: alle Zeilen einrücken
\makeatletter
\newlength{\myFootnoteWidth}
\newlength{\myFootnoteLabel}
\setlength{\myFootnoteLabel}{1.2em}%  <-- can be changed to any valid value
\renewcommand{\@makefntext}[1]{%
  \setlength{\myFootnoteWidth}{\columnwidth}%
  \addtolength{\myFootnoteWidth}{-\myFootnoteLabel}%
  \noindent\makebox[\myFootnoteLabel][r]{\@makefnmark\ }%
  \parbox[t]{\myFootnoteWidth}{#1}%
}
\makeatother

% ---------- normal title ---------- %
\titlepage
\maketitle
\thispagestyle{empty}
\newpage
\thispagestyle{empty}
\mbox{}

% ---------- Fancyheader ---------- %
\fancyhead[L]{}
\fancyhead[R]{}
\fancyfoot[C]{\today}
\fancyfoot[R]{\footnotesize \thepage{}}
\renewcommand{\headrulewidth}{0pt}
\setlength{\headheight}{24pt}

% generates the title


% ---------- table of contents ---------- %
\newpage
\pagenumbering{roman}
%\addcontentsline{toc}{section}{Inhaltsverzeichnis}
\pdfbookmark[1]{Inhaltsverzeichnis}{myPDFtocLabel}
\tableofcontents

\cleardoublepage
\pagenumbering{arabic}
\newcommand\todo[1]{\footnote{\textcolor{red}{TODO: #1}}}
\newcommand\fcite[1]{\footnote{\cite{#1}}}
\newcommand\fciteX[2]{\footnote{\cite{#1}, #2}}

\section{Zielstellung}

In der Echtzeit-3D-Graphik werden für 3D-Objekte überwiegend Dreiecksnetze\footnote{engl. ``triangle mesh'' und kürzer ``mesh''; siehe z.B. \cite{watt_de}}
verwendet. Dies spiegelt sich in dem Aufbau von 3D-Graphikprozessoren~("`GPU"') wie auch
den Programmierschnittstellen~(\cite{glspec4}, \cite{dx10}) wieder. Insbesondere bei der Programmierung der GPU müssen
separate Vertex- und Fragmentprogramme % Ref oder Erklärung was Vertex/Fragment
erstellt werden. Diese Aufteilung sowie die Definition der "`Schnittstelle"' zwischen den Verarbeitungseinheiten muss vom Programmierer manuell vorgenommen werden.

Ziel dieser Arbeit ist es, einen Compiler zu entwickeln, der die Aufteilung in Vertex- und Fragmentprogramme (und auch Schnittstellendefinition)
automatisch vornimmt,
ohne dass der Programmierer explizit angeben muss, auf welcher der Funktionseinheiten ein bestimmter Befehl ausgeführt wird.
Die zu compilierende Sprache wird in Abschnitt~\ref{langspec} spezifiziert. Die Compilerimplementierung wird in Abschnitt~\ref{implementation}
beschrieben.

% Nochmal Abschnitt mit kurzer Beschreibung wichtiger Konzepte? (meshes, Vertices vs Fragmente, ...)

\section{Sprachspezifikation}
\label{langspec}

\input{langspec}

\section{Implementierung}
\label{implementation}

\subsection{Compiler-Aufbau}
\begin{figure}[h]
   \centering
  \includegraphics{compiler_structure}
  \caption{Schematischer Aufbau des Compilers}
  \label{fig:structure}
\end{figure}

Der Aufbau entspricht grösstenteils dem, was für einen Compiler üblich ist: das \emph{Front-End} generiert nach Syntax- und Semantikanalyse
eine Repräsentation des Programms in einem \emph{Zwischencode}. Auf dieser Zwischenrepräsentation werden im "`Middle-End"' % Ref wo das gesagt wird, oder besseres Wort
Optimierungen vorgenommen. Im letzten Schritt wird im \emph{Back-End} aus der optimierten Zwischenrepräsentation der tatsächliche Zielcode generiert.

Besonderheit dieses Compilers ist der Schritt \emph{Auftrennung VP/FP}. Hier wird für jeden Befehl der Zwischenrepräsentation untersucht, mit
welcher Berechnungsfrequenz~(siehe \ref{Berechnungsfrequenz})\footnote{Es wird auch "`Meshfrequenz"' definiert, aber der Einfachheit halber
trennt diese Implementierung bloß in Vertex- und Fragmentfrequenz. Das Konzept ist jedoch auch auf weitere Frequenzen erweiterbar.}
jeder Befehl des Programms ausgeführt werden muss - mit anderen Worten,
es wird untersucht, welche Befehle auf der Vertex-Einheit oder der Fragment-Einheit ausgeführt werden müssen. Mit diesen Informationen kann
das Programm entsprechend in ein Vertex- und ein Fragment-Programm aufgeteilt werden. Da zur Laufzeit auch ein "`Übergeben"' von Ausgaben
des Vertexprogramms an Eingaben des Fragmentprogramms stattfindet wird auch eine den Vertex-Ausgaben zu Fragment-Eingaben
abbildende "`Schnittstelle"' generiert.

Die Programme werden vom Aufspalter in Zwischencode ausgegeben und können noch einmal optimiert werden. % Irgendein besonderer Vorteil?
Abschließend werden ein Fragment- und ein Vertexprogramm im gewünschten Zielcode ausgegeben\footnote{Diese Implementierung benutzt den
gleichen Generator für beide Programme, prinzipiell könnten diese jedoch mit verschiedenen Generatoren ausgegeben werden.}.

\subsection{Implementierungsdetails}

Als \emph{Programmiersprache}, in der die hier beschriebene Implementierung verfasst ist, wurde C++ gewählt.
Gründe dafür sind:
\begin{itemize}
\item Die Flexibilität der Sprache und deren reichhaltige Standardbibliothek,
\item hohe Portabilität (C++-Compiler sind für praktisch jede Plattform verfügbar),
\item eine reichhaltige Palette an von Dritten hergestellter Bibliotheken,
\item die einfache Bindbarkeit an andere Sprachen (direkt oder über eine C-kompatible Schnittstelle),
\item nicht zuletzt die Gewandheit des Autors dieser Arbeit in C++.
\end{itemize}
 
Um eine Wiederverwendung des Compilers zu vereinfachen wurde dieser im Wesentlichen als eine \emph{Bibliothek} realisiert;
eine "`Kommandozeilenversion"' des Compilers setzt auch auf diese Bibliothek auf.
 
Zur Sicherstellung der fortwährend korrekten Funktionsweise aller Module des Compilers wurden entwicklungsbegleitend 
jeweils \emph{Tests} der Module geschrieben (Black-Box und White-Box); Ausführen der Tests war regelmässiger Teil des Entwicklungsprozesses.
 
\subsection{Lexer}

Der \emph{Lexer} wandelt die als Byte-Strom vorliegende Eingabe in eine Folge von "`Tokens"'.
Ein Token ist eine der in Abschn.~\ref{Lexikalische Einheiten} aufgezählten lexikalischen Einheiten, ein bekanntes Symbol (Operatoren etc.) oder Schlüsselwort. 
Leerzeichen (``Whitespace'') und Kommentare werden bereits vom Lexer ignoriert (d.h. für diese werden keine Tokens produziert).

Der Lexer folgt einer typischen Implementierung wie sie z.B. in \cite{wirth_compiler} beschrieben ist. Auf einige beachtenswerte Aspekte
wird im folgenden eingegangen.

\paragraph{Eingabe.} Da die Spezifikation von Unicode als Eingabe ausgeht, arbeitet der Lexer entsprechend auf der Basis von Unicode-kodierten Zeichen.
Der Byte-Strom der Eingabe wird also in einem Schritt noch vor dem Lexer in einen "`Unicode-Strom"' umkodiert\footnote{Verwendet wird dazu die Bibliothek ICU,
\url{http://site.icu-project.org/}}.

\paragraph{Schlüsselwörter.} Erkennt der Lexer einen Bezeichner, wird auch geprüft, ob es sich um ein Schlüsselwort handelt. Ist dies der Fall
wird im Token eine dem Schlüsselwort eindeutig zugeordnete ID gespeichert.

Die erste Ausnahme allerdings bilden die Schlüsselwörter für Vektor- und Matrixtypen (Abschn.~\ref{Vektortypen}, \ref{Matrixtypen}). Diese entsprechen
jeweils dem Muster $\mathit{typ}\mathrm{N}$ bzw. $\mathit{typ}\mathrm{N}\mathit{x}\mathrm{M}$ (mit $N \in 1 \dots 4, M \in 1 \dots 4$).
Da eine eigene ID für jeden Vektor- oder Matrix insgesamt 20 weitere IDs pro Basis-Typ nach sich ziehen würde -- wobei später noch jeder ID wiederum
die ursprünglichen Werte für $N$ und $M$ nochmals zugeordnet
werden müssten -- wird generierten Token vermerkt, ob es sich um einen Vektor- oder Matrixtyp handelt.
Dazu überprüft der Lexer, ob ein Bezeichner den angegebenen Muster für Vektor- bzw. Matrixschlüsselwörtern entspricht.
Weiterhin werden bereits $N$ bzw. $M$ aus den Bezeichnern extrahiert und ebenfalls vermerkt.

\begin{figure}[h]
   \centering
  \lstinputlisting[language=C++]{snips/LexerToken.txt}
  \caption{Daten eines vom Lexer ausgegebenen Tokens}
  \label{fig:LexerToken}
\end{figure}

Die zweite Ausnahme bilden Attributnamen~(\ref{Attribute}) inklusive Swizzles~(\ref{Vektorattribute}). Diese sind teilweise recht allgemein, und
es erscheint wünschenswert, Bezeichner zuzulassen, die Attributnamen entsprechen -- z.B. ``length'', das auch ein Arrayattribut ist, und einbuchstabige
Bezeichner wie ``x'', ``y'' etc., welche auch Vektorattribute (Swizzles) sind. Syntaktisch gibt es keine Mehrdeutigkeiten zwischen Attributen und
anderen Bezeichnern -- ein Attribut kann \emph{nur} rechts eines \op{.} auftauchen, ein anderer Bezeichner dort nie.

Weiterhin schreibt die Spezifikation vor, dass zwei Bezeicher als identisch betrachtet werden, wenn sie kanonisch äquivalent im Sinne von Unicode sind.
Zu diesem Zweck werden alle Bezeichner vom Lexer nach einer von Unicode vorgegebenen Form normalisiert~(\cite{unicode}, Annex \#15).

\subsection{Parser}

Der \emph{Parser} (oder auch "`Scanner"') untersucht den vom Lexer gelieferten Strom von Tokens auf syntaktische Strukturen.
Es wird überprüft, ob der Token-Strom gültig im Sinne der in der Sprachspezifikation gegebenen Sprache ist --
sonst liegt ein \emph{Syntaxfehler} vor.

Während der Überprüfung werden auch syntaktische Elemente -- grundsätzlich Terminale wie Bezeichner oder numerische Werte -- extrahiert.
Diese werden bei der \emph{semantischen} Verarbeitung benötigt.

%- Lookahead: unendl.
%- Grammatik: kontextfrei, rechtsrekursiv

%\subsubsection{Eigenschaften der Grammatik}

%Die Grammatik ist kontextfrei. Die Regeln sind rechtsrekursiv.

\subsubsection{Aufbau des Parsers}
%- SemanticHandler

\newcommand\rulelink[1]{\glq\texttt{\detokenize{#1}}\grq~(\ref{#1})}

Der Parser ist handprogrammiert nach der Methode des rekursiven Abstiegs (beschrieben in \cite{wirth_compiler}).
Der Aufbau spiegelt im Wesentlichen die Struktur der Regeln wieder -- viele haben ein direktes Gegenstück in einer Methode des Parsers.

\paragraph{Umgang mit Mehrdeutigkeiten:}
An einigen Stellen der Grammatik gibt es Mehrdeutigkeiten.
Wird beim parsen eines \rulelink{programm_statements} die Tokens \glq\texttt{typ BEZEICHNER}\grq~(\ref{typ}, \ref{BEZEICHNER})  erkannt,
so kann es sich entweder um die Regel \rulelink{dekl_funktion} oder um \rulelink{dekl_var} handeln.
Andere Fälle von Mehrdeutigkeiten sind \rulelink{dekl_var} oder \rulelink{kommando} in \rulelink{block},
\rulelink{funktion_aufruf} oder \rulelink{BEZEICHNER} in \rulelink{asdr_basis}.

Solche Mehrdeutigkeiten lassen sich entweder in der Implementierung des Parsers oder durch Abändern der Grammatik lösen.

Bei der Parser-Lösung werden einfach weitere Tokens betrachtet. Im Falle eines  \rulelink{programm_statements}
wird auch das nächste Token nach \glq\texttt{typ}\grq{} und \glq\texttt{BEZEICHNER}\grq{} überprüft:
handelt es sich um \glq\texttt{(}\grq, ist die anzuwendende Regel \rulelink{dekl_funktion};
handelt es sich um \glq\texttt{=}\grq, \glq\texttt{,}\grq{} oder \glq\texttt{;}\grq{} ist die anzuwendende Regel \rulelink{dekl_var};
andere Tokens sind ein Syntaxfehler.

In den Implementierungen der Regeln \rulelink{block} und \rulelink{asdr_basis} wurde analog verfahren.

Bei der Lösung von Mehrdeutigkeiten durch Abändern der Grammatik muss eine Regel erstellt werden,
die mit der mehrdeutigen Token-Sequenz beginnt. Dahinter werden als Alternativen neue Regeln angefügt,
die aus den "`Resttokens"' der ursprünglich mehrdeutigen Regeln bestehen müssen. % Hier ne Ref wäre vllt gut

Allerdings wird damit die Lesbarkeit der Grammatik eingeschränkt; nur für die Regel \rulelink{ausdruck} wurde dieser Ansatz verfolgt.
Für die anderen Regeln wurde das "`Vorausbetrachten"' im Parser gewählt, da es in diesen Fällen einfach zu implementieren war
und die Grammatik besser lesbar bleibt.

\begin{figure}[h]
   \centering
  \lstinputlisting[language=C++]{snips/ParseProgramStatements.txt}
  \caption{Beispiel einer Parsing-Methode mit Auflösung von Mehrdeutigkeiten}
  \label{fig:ParseProgramStatements}
\end{figure}

\paragraph{Semantische Verarbeitung:}
Die semantische Verarbeitung wird an ein Interface vom Typ \verb+SemanticHandler+ übergeben.
Dieses Interface übernimmt die verschiedenen Aspekte der semantischen Verarbeitung, von der Verwaltung der
Symboltabelle bis zu einer geeigneten internen Repräsentation von Ausdrücken.

\verb+SemanticHandler+ besitzt Methoden, um syntaktische Elemente -- wie Bezeichner und numerische Literale -- in Objekte 
einzukapseln. Diese Objekte wiederum werden bei der Verarbeitung anderer syntaktischer Elemente
zurück an das Interface übergeben. % Wenn Code-Schnipsel dann hier verweisen

%Beispiel: Bei einem Ausdruck \verb+a * 2+ werden von \verb+SemanticHandler+ zunächst Repräsentationen für
%\verb+a+ und \verb+2+ erfragt. Zurückgegeben werden Repräsentationen von "`Ausdrücken"'. Diese wiederum
%dienen als Argumente, um eine Repräsentation einer Multiplikation zu erhalten. Diese letzte Repräsentation kann
%dann überall dort verwendet werden, wo Ausdrücke erwartet werden: Zuweisungen, Funktionsparameter etc.

Vom der \verb+SemanticHandler+-Implementierung zum Parser gibt es auch einen "`Rückkanal"'. Dies ist nötig, da bei einigen
Konstrukten bekannt sein muss, ob ein Bezeichner eine Variable, eine Funktion oder einen Typ identifiziert:
Das Ausdruck \verb+foo (1)+ ist, je nachdem ob \verb+foo+ eine Funktion, ein Typ-Alias oder eine Variable bezeichnet,
entsprechend ein ein Funktionsaufruf, der Aufruf eines Typ-Konstruktors, oder ein ungültiger Ausdruck.

Die Idee hinter dem \verb+SemanticHandler+ ist eine möglichst vollständige Trennung zwischen syntaktischer
und semantischer Verarbeitung. Eine minimale Implementierung könnte intern eine
AST-Repräsentation generieren (allerdings benötigt der Parser trotzdem auch einige semantische Informationen über
Bezeichner).

\begin{figure}[h]
   \centering
  \lstinputlisting[language=C++]{snips/ParseIf.txt}
  \caption{Zusammenspiel Parser und \texttt{SemanticHandler}: Parsen einer Verzweigung}
  \label{fig:ParseIf}
\end{figure}

\paragraph{Fehlerbehandlung:}
Die Fehlerbehandlung bei der syntaktischen wie auch semantischen Verarbeitung wird über \emph{Ausnahmen}
realisiert. Der Parser selbst fängt dabei Ausnahmen ab, um zu gewährleisten, dass möglichst viel eines
Programms verarbeitet wird, um möglichst viele potentielle Fehler aufzudecken: % Wirth
tritt z.B. eine Ausnahme während der Verarbeitung eines Block-Kommandos auf, setzt der Parser die
Verarbeitung nach dem nächsten Semikolon -- also mit dem nächsten Kommando -- fort (sofern kein Ende
des Blockes festgestellt wird).
Die abgefangen Ausnahmen werden jedoch nicht verworfen, sondern an ein Objekt zur Fehlerbehandlung
übergeben (um z.B. eine Ausgabe auf der Konsole vorzunehmen).

Die Idee hinter dem \verb+SemanticHandler+ ist eine möglichst vollständige Trennung zwischen syntaktischer
und semantischer Verarbeitung. Eine minimale Implementierung könnte intern eine (annähernde)
AST-Repräsentation generieren (nur "`annähernd"' da der Parser einige semantische Informationen über
Bezeichner benötigt). In der tatsächlichen Implementierung wird vom \verb+SemanticHandler+ allerdings 
gleich eine Umsetzung in die Zwischenrepräsentation vorgenommen (Beschreibung siehe Unten):
die Generierung eines ASTs wurde als Zwischenschritt wurde als unnötigen angesehen, da die Zwischenrepräsentation
wichtige semantische Eigenschaften (wie Typinformationen) erhält und sich die Verarbeitungsschritte "`Auftrennung"'
und "`Optimierung"' auf dieser besser vornehmen lassen.

\paragraph{Implementierung \texttt{SemanticHandler}:}
In der vorgenommen Implementierung von \verb+SemanticHandler+ wird gleich eine Umsetzung in die Zwischenrepräsentation vorgenommen
(Beschreibung siehe Unten). Die Generierung eines ASTs als Zwischenschritt wurde als unnötig angesehen.
Die Zwischenrepräsentation erhält auch wichtige semantische Eigenschaften (wie Typinformationen) und
die Verarbeitungsschritte "`Auftrennung"' und "`Optimierung"' lassen sich auf der Zwischenrepräsentation besser vornehmen.

% Zuordnung Variable <-> akt. Register in Symboltabelle

\subsection{Zwischenrepräsentation}

% Abstrakte(s) Beispiel(e): Quellcode + resultierende Zw.rep.

\subsubsection{Vorlagen der Zwischenrepräsentation}

Als Vorlagen für die hier vorgestellte Zwischenrepräsentation dienten das ``LLVM Instruction Set''~(\cite{LLVM:CGO04}),
SafeTSA~(\cite{SafeTSA}) und ``SIMPLE'' des McCAT Compiler-Projektes~(\cite{SIMPLE}).

% "Inspirationen": LLVM, Amme's SSA, GIMPLE/SIMPLE

%Das \emph{LLVM Instruction Set} (hier kurz ``LLVM'') 
\paragraph{LLVM}: LLVM ist ein \emph{Framework} für Compiler. Insbesondere will es ermöglichen, Optimierungen
eines Programms über dessen ganzen "`Lebenszyklus"' (inklusive Link- und Laufzeit) zu ermöglichen.

Das \emph{LLVM Instruction Set} ist der ausgegebene "`Objektcode"'. Das Programm wird -- ähnlich Maschinen-
oder Bytecode -- als eine Folge von einfachen Instruktionen auf Registern repräsentiert. 
Allerdings gibt es eine unendliche Anzahl von typisierten Registern und Typumwandlungen sind immer explizit.
Die Instruktionen sind in SSA-Form.

% LLVM:
% - nicht gedacht als allg. Compiler-IR
% - keine Typsicherheit (nicht mehr als Maschinencode)
% - 
% - LLVM provides an inﬁnite set of typed virtual
% registers which can hold values of primitive types (Boolean,
% integer, ﬂoating point, and pointer). The virtual registers
% are in Static Single Assignment (SSA) form [15]. LLVM
% is a load/store architecture: programs transfer values be-
% tween registers and memory solely via load and store op-
% erations using typed pointers. The LLVM memory model is
% described in Section 2.3.
% - Opcodes: 3-Adress-Form
% - Ich->Mehr Opcodes als LLVM (unäre Op., Vektor-Op.)
% - Expliziter Kontrollflussgraph
% - abgeleitete Typen: Zeiger, Arrays, Structs, Funktionen
% - Typumwandlungen: explizit

% expliziter Kontrollfluss == keine GOTOs, sondern "Verweise" auf Blöcke/nächsten Schritt

\paragraph{SafeTSA:} Eine Art Objektcode, hauptsächlich zur Benutzung
als "`mobiler"' Code, d.h. zur Übertragung von Programmcode über Netzwerke wie das Internet.
Das Design von SafeTSA ist inhärent sicher. Bösartige Manipulationen von Programmen, die zu
problematischem Verhalten wie die Benutzung von undefinierten Werten oder Aliasing von Werten
eines anderen Typs führen, sind nicht möglich bzw. durch eine einfache Verifizierung feststellbar.

Die Instruktionen basieren auf der SSA-Form. Entsprechend gibt es eine unendliche Zahl von Registern.
Register sind in mehrere Sätze organisiert, ein Satz pro Typ. Instruktionen können nur auf einen
spezifischen Registersatz zugreifen. Verschiedene Instruktionsblöcke besitzen eigene Registersätze.

% SafeTSA:
% - erweiterte SSA
% - Zugriff auf Werte über Abstand in Dominatorbaum
% - Typtrennung: mehrere Registersätze; implizite Auswahl des Registersatzes
% - typisierter Konstantenpool
% - Registersätze per Basisblock
% - 

\paragraph{SIMPLE:} Als "`echte"' Compiler-Zwischenrepräsentation für einen C-Compiler entwickelt
stellt sie Programme auf sehr hoher Ebene dar. Ausdrücke sind nicht in der SSA-Form, allerdings
"`vereinfacht"' auf zwei Operanden und einfache Strukturzugriffe. Symboltabelle und Typinformationen
sind erhalten. Typumwandlung, und andere in C implizite Verhalten, müssen explizit ausgedrückt werden.

% SIMPLE:
% - expliziter Kontrollfluss/zusammengesetzte Flusskontrollstatements
% - Typinformationen
% - klare Semantik (keine impliziten Verhalten wie autom. casts)
% - einfache Referenzen
% - einfache Statements

\paragraph{Zusammenfassung:}
Die gewählte Zwischenrepräsentation ist größtenteils ein "`Querschnitt"' aus den obigen Repräsentationen
(allerdings auch mit Aspekten aus keiner Vorlage, wie die Behandlung von Arrays). Am meisten Eigenschaften
teilt die Zwischenrepräsentation mit dem LLVM Instruction Set; chronologisch wurde dieses jedoch als letzte
Repräsentation betrachtet. Aus SafeTSA und SIMPLE stammen deshalb grundsätzliche Aspekte der Zwischenrepräsentation 
-- einfache Statements, SSA-Form, separate Registersätze.

Anzumerken ist, dass die Shadingsprache keine zufälligen Speicherzugriffe oder Zeiger/Referenzen erlaubt.
Im Umfang ist sie teilweise beschränkt -- es gibt keine Strukturtypen --, besitzt aber als "`Eigenheit"' Vektortypen.
LLVM, SafeTSA und SIMPLE wurden für "`Maschinen"' entwickelt, die die Verwendung von Zeigern erlauben. Entsprechend
stellen sie Lösungen für Probleme, wie die Aliasing\footnote{Zugriff auf ein Datum über mehrere verschiedene Zeiger}-Analyse oder typsichere Speicherzugriffe, bereit, die mit
der hier spezifizierten Shadingsprache nicht vorkommen. Insofern sind diese Repräsentationen hier nicht
mit ihren vollständigen Fähigkeiten beschrieben.

\subsubsection{Aufbau}

Die \emph{Zwischenrepräsentation} basiert im Wesentlichen auf der SSA-Form (Single Static Assignment).

% SSA:  B. Alpern, M. N. Wegman, and F. K. Zadeck. Detecting equalities of
%variables in programs. In 15th Annual ACM Symposium on Principles of
%Programming Languages, pages 1–11, San Diego, California, Jan. 1988.
% B. K. Rosen, M. N. Wegman, and F. K. Zadeck. Global value numbers and
%redundant computations. In 15th Annual ACM Symposium on Principles of
%Programming Languages, pages 12–27, San Diego, California, Jan. 1988.

Die Zwischenrepräsentation ist um "`Sequenzen"' herum organisiert. Eine Sequenz besteht aus "`Operationen"',
die auf "`Registern"' arbeiten. Register sind \emph{typisiert}, es gibt einen Registersatz für jeden verwendeten Typ.
% Satz teil von Register-ID
%Jedes Register besitzt ausserdem einen Namen; dieser wird aber nur verwendet, um generierten Code lesbarer zu machen.
Der wesentliche, von der SSA-Form entliehene, Aspekt ist, dass ein Register nur von \emph{einer} Operation der Sequenz beschrieben werden darf.

\begin{figure}[h]
   \centering
  \includegraphics{ir_sequence}
  \caption{Teile einer Sequenz}
  \label{fig:ir_sequence}
\end{figure}

Die Sichtbarkeit von Registern ist auf die Sequenz, in der sie deklariert wurden, beschränkt.
%Insbesondere können auf diese nicht implizit
%aus verschachtelten Blöcke (wie sie auch bei Bedingungen oder Schleifen vorkommen) zugegriffen werden. 
Insbesondere gibt es Sequenzoperationen, die andere Sequenzen einschachteln (Verzweigungen, Schleifen, Sequenzschachtelung).
Aus solch eingeschachtelten Blöcken kann \emph{nicht} implizit auf die Register aus dem umgebenden Block
zugegriffen werden.

Stattdessen werden zu eingeschachtelten Blöcken eine Zuordnung zwischen Registern aus dem umgebenden Block
("`extern"') und
Registern des eingeschachtelten Blockes ("`lokal"') gespeichert.
Semantisch findet am Anfang des Blockes ein Kopieren von externen Eingaberegistern
in lokale Register statt. Analog findet am Ende ein zurückkopieren von lokalen Registern in die externen Ausgaberegister.
(Die genaue Umsetzung dieses Verhaltens ist ein Implementierungsdetail, dass dem Generator obliegt.)

\begin{figure}[h]
   \centering
  \includegraphics{ir_seq_block_nest}
  \caption{Schema einer Sequenzschachtelung}
  \label{fig:ir_seq_block_nest}
\end{figure}

\paragraph{Funktionen:}
Eine Funktion der Zwischenrepräsentation besteht aus einem eindeutigem Bezeichner, einer Liste von Eingabeparametern,
einer Liste von Ausgabeparametern und einer Sequenz mit den eigentlichen Funktionsoperationen.

Jede Überladung einer Funktion wird in der Zwischenrepräsentation durch einen eindeutigen Bezeichner identifiziert.
Dieser wird aus dem ursprünglichen Bezeichner sowie einer aus den Parametertypen generierten "`Signatur"' konstruiert.

Parameter werden mit einem Mechanismus, der der Behandlung "`externer"' Register in einem eingeschachteltem
Block ähnelt, übergeben. Die Parameterlisten enthalten zu jedem Eingabeparameter ein lokales Register, in dem die
Sequenz den Wert des Parameters "`erwartet"'. Analog wird jedem Ausgabeparameter ein Register zugeordnet,
in dem bei Verlassen der Funktion der zurückzugebende Wert liegt.
(Die genaue Umsetzung dieses Verhaltens ist ein Implementierungsdetail, dass dem Generator obliegt.)

Ein Parameter, der gleichzeitig Ein- wie auch Ausgabeparameter ist, wird "`verdoppelt"', d.h. es wird daraus
ein nur-Eingabe- sowie auch ein nur-Ausgabe-Parameter generiert. Bei Funktionsaufrufen werden den beiden
Parametern auch entsprechend verschiedene Register zugeordnet.

\begin{figure}[h]
   \centering
  \includegraphics{ir_function}
  \caption{Schema einer Funktionsbeschreibung}
  \label{fig:ir_function}
\end{figure}

\paragraph{Globale Variablen:}
Echte globale Variablen sind nicht vorgesehen. Sie werden nachgebildet, in dem in einer Funktion gelesene globale Variable
auf einen speziellen, "`versteckten"' Eingabeparameter abgebildet wird. Eine geschriebene globale Variable wird
auf einen speziellen Ausgabeparameter abgebildet. Nur in der Eintrittsfunktion werden globalen Variablen tatsächlich
"`eigene"' Register zugewiesen. Im Prinzip sind "`globale"' Variablen bloss "`versteckte"' lokale Variablen in
der Eintrittsfunktion.

%Stattdessen werden zu eingeschachtelten Blöcken gespeichert, welche Register von dem Block gelesen oder
%beschrieben werden sollen

%Soll ein Register in einem eingeschachteltem Block gelesen oder beschrieben werden, 

\paragraph{Behandlung von Arrays:}
Arrays werden als "`ein"' Wert behandelt. D.h. eine Zuweisungsoperation kopiert immer ein ganzes Array.
Das Lesen einzelner Elemente geschieht mit Hilfe der Operation "`Extraktion eines Arrayelements"'.
Zum Schreiben eines Elements gibt es die Operation "`Änderung eines Arrayelements"'; diese kopiert alle Elemente
eines Arrays in das Zielarray \emph{außer} das Element eines gegebenen Indexes; im Zielarray wird dort der zu
schreibende Wert abgelegt.

Dieser Ansatz wurde gewählt, weil er sehr gut in das "`SSA-Prinzip"' passt.
Bei der direkten Umsetzung eines Zugriffs auf Array-Elemente ("`$a[i] = x$"') ist es schwierig, sicherzustellen, dass
jedes Element von $a$ wie verlangt nur einmal beschrieben wird (insbesondere bei Schleifen); es
müsste für jedes Array-Element individuell "`verfolgt' werden, ob es beschrieben wurde.
Ein solches Verfolgen wird weiterhin schwieriger, sobald die Array-Größe nicht bekannt ist
-- die spezifizierte Sprache sieht dies vor. Das betrachten eines Arrays als "`einen"' Wert macht es hingegen einfach,
die Bedingung "`nur eine Zuweisung"' einzuhalten und zu überprüfen.
% Andere Alternativen? Wie in LLVM, SafeTSA? Wer hat sich noch über Arrays Gedanken gemacht?

Für manche Optimierungen ist es trotzdem von Vorteil, die einzelnen Element eines Arrays zu verfolgen -- sind diese
z.B. Konstanten können die Werte an einer Konstantenfaltung teilnehmen. Solche Möglichkeiten der Optimierungen
bleiben bestehen: sind Größe und Elementwerte eines Arrays bekannt, kann ein Optimierer diese wie individuelle
Register durch die Arrayoperationen hindurch verfolgen, oder sogar ein Array auf individuelle Register "`aufteilen"'.

\subsubsection{Sequenz-Operationen}

Dieser Abschnitt zählt alle Möglichen Operationen in einer Sequenz auf. Eine Operation greift für die Eingabe auf kein, ein oder mehrere
\emph{Quellregister} zu. Hat die Operation ein Ergebnis, wird dieses in ein \emph{Zielregister} geschrieben. 

Unter vielen Operationen ist Verhalten in Pseudo-Code angegeben. Dabei steht $d$ für das Zielregister einer Operation.
Die Quellregister werden durch $s$, $t$, \dots bezeichnet. 

\paragraph{Zuweisungsoperation:} Kopiert Inhalt eines Registers in ein anderes.
\\\hspace*{1cm}$d = s$

\paragraph{Konstantenoperation:} Diese weist dem Zielregister eine Bool'sche, Integer- (vorzeichenlos oder vorzeichenbehaftet) oder
Fließkommakonstante zu.
\\\hspace*{1cm}$d = \mathrm{Konstante}$

\paragraph{Typumwandlungsoperation:} Liest das Eingaberegister, wandelt dessen Wert in den Ziel-Typ und schreibt den umgewandelten Wert in das Zielregister.
Kann zwischen Integer- (vorzeichenlos oder vorzeichenbehaftet) und Fließkommawerten umwandeln.
\\\hspace*{1cm}$d = s\ \mathrm{als}\ \mathrm{"`Ziel-Typ``}$

% Eventuell Tabelle (Operation|Verknüpfung|Eing-Typ|Ausg-Typ) statt Prosa?
\paragraph{Arithmetische Operation:} Zwei Eingaberegister 
werden durch eine arithmetische Operation verknüpft und das Ergebnis in das Zielregister geschrieben.
Die Eingaberegister und das Zielregister müssen vom gleichen Typ sein -- Integer- (vorzeichenlos oder vorzeichenbehaftet) und Fließkommawerte.
\\\hspace*{1cm}$d \gets s + t$
\\\hspace*{1cm}$d \gets s - t$
\\\hspace*{1cm}$d \gets s * t$
\\\hspace*{1cm}$d \gets s / t$

\paragraph{Vergleichsoperation:} Zwei Eingaberegister 
werden miteinander verglichen (gleich, ungleich, größer, größer gleich, kleiner oder kleiner gleich) und das Ergebnis in das Zielregister geschrieben.
Die Eingaberegister müssen vom gleichen Typ sein -- Integer- (vorzeichenlos oder vorzeichenbehaftet) und Fließkommawerte.
Das Zielregister muss vom Typ Boolean sein.
\\\hspace*{1cm}$d \gets s = t$
\\\hspace*{1cm}$d \gets s < t$
\\\hspace*{1cm}$\phantom{d \gets}\vdots$

\paragraph{Logische Operation:} Zwei Eingaberegister durch logisch UND oder logisch ODER verknüpft und das Ergebnis in das Zielregister geschrieben.
Die Eingaberegister und das Zielregister müssen vom Typ Boolean sein.
\\\hspace*{1cm}$d \gets s \land t$
\\\hspace*{1cm}$d \gets s \lor t$

\paragraph{Unäre Operation:} Unäre Operationen sind Negation, Logisches NICHT und bitweise Invertierung.
Negation negiert den Wert des Eingaberegisters und schreibt das Ergebnis in das Zielregister.
Die Eingabe- und das Zielregister müssen vom gleichen Typ sein -- Integer- (vorzeichenlos oder vorzeichenbehaftet) und Fließkommawerte.\\
Logisches NICHT invertiert den Wert des Eingaberegisters und schreibt das Ergebnis in das Zielregister.
Die Eingabe- und das Zielregister müssen vom gleichen Typ Boolean sein.\\
Bitweise Invertiertung wird auf das Eingaberegister angewendet und schreibt das Ergebnis in das Zielregister.
Die Eingabe- und das Zielregister müssen von einem Integer-Typ (vorzeichenlos oder vorzeichenbehaftet) sein.
\\\hspace*{1cm}$d \gets \neg s$
\\\hspace*{1cm}$d \gets -s$
\\\hspace*{1cm}$\phantom{d \gets}\vdots$

\paragraph{Vektor-Erstellung:} Nimmt als Eingabe ein bis vier Register, je nach der Komponentenanzahl des Zielregisters. Die Eingaberegister müssen alle
den Basistyp des Zielregisters besitzen. Sie werden der Reihe nach den Vektorkomponenten im Zielregister zugeordnet.
\\\hspace*{1cm}$d \gets (s)$
\\\hspace*{1cm}$d \gets (s, t)$
\\\hspace*{1cm}$\phantom{d \gets}\vdots$

\paragraph{Extraktion einer Vektorkomponente:} Nimmt neben einem Eingaberegister auch eine Integer-Konstante $N$ im Bereich $0 \dots 3$ entgegen.
Das Eingaberegister muss von einem Vektortyp sein. Das Zielregister muss vom Basistyp des Vektors sein.
Aus dem Eingabevektor wird die Komponente Nummer $N$ extrahiert und in das Zielregister geschrieben.
\\\hspace*{1cm}$d \gets s_N$

\paragraph{Matrix-Erstellung:} Nimmt als Eingabe ein bis sechzehn Register, je nach den Dimensionen des Zielregisters. Die Eingaberegister müssen alle
den Basistyp des Zielregisters besitzen. Siew werden der Reihe nach den Elementen im Zielregister zugeordnet: zuerst das Element der ersten Spalte in der ersten Zeile,
als nächstes das Element der zweiten Spalte in der ersten Zeile, usw.
\\\hspace*{1cm}$d \gets \left(s\right)$
\\\hspace*{1cm}$d \gets \left(\begin{array}{cc}s&t\\u&v\end{array}\right)$
\\\hspace*{1cm}$\phantom{d \gets}\vdots$

\paragraph{Array-Erstellung:} Nimmt als Eingabe eine Variable Anzahl von Registern, die Anzahl der Eingaberegister bestimmt die Länge des Arrays.
Die Eingaberegister müssen alle den Basistyp des Zielregisters besitzen. Sie werden der Reihe nach den Array-Elementen im Zielregister zugeordnet.
\\\hspace*{1cm}$d \gets (s, t, \dots)$

\paragraph{Extraktion eines Arrayelements:} Verwendet zwei Eingaberegister: ein Arrayregister sowie als Index ein Register mit einem vorzeichenlosen Integer.
Aus dem Array wird das Element mit dem gegebenen Index extrahiert und in das Zielregister geschrieben.
Das Zielregister muss den Basistyp des Array-Registers besitzen.
\\\hspace*{1cm}$d \gets s[t]$

\paragraph{Änderung eines Arrayelements:} Verwendet drei EIngaberegister: neben einem Arrayregister und dem Indexregister (vorzeichenloser Integer)
weiterhin ein Register mit vom Basistyps des Arrays (der "`neue Wert"').
Aus dem Eingabearray werden alle Elemente \emph{außer} das Element des gegebenen Indexes in das Zielarray kopiert;
dort wird stattdessen der "`neue Wert"' abgelegt. Das Zielregister muss den Typ des Arrayregisters besitzen.
\\\hspace*{1cm}$d \gets (x | x = s[i]\ \mathrm{f"ur\ alle}\ i \neq t, u\ \mathrm{sonst})$

\paragraph{Arraylänge:} Nimmt im Eingaberegister ein Array entgegen. Schreibt in das Zielregister, welches vom Typ "`vorzeichenloser Integer"' sein muss,
die Anzahl der Elemente des Arrays.
\\\hspace*{1cm}$d \gets |s|$

\paragraph{Sequenzschachtelung:} Eine Operation, die auf eine weitere, eingeschachtelte Sequenz verweist, welche beim Ausführen der Operation abgearbeitet wird.
Neben dem Verweis auf eine Sequenz werden auch Listen von "`importierten"' und "`exportierten"' Namen zu der Operation gespeichert.
Jedem Namen ist weiterhin ein Register in der eingeschachtelten Sequenz zugeordnet.

Beim Einfügen der Operation in eine "`umgebende"' Sequenz wird von dieser eine Zuordnung von "`importierten"' und "`exportierten"' Namen der
eingeschachtelten Sequenz zu Registern der umgebenden Sequenz vorgenommen. 
Diese Zuordnung wird benutzt, um vor der Abarbeitung der eingeschachtelten Sequenz Registerwerte von der umgebenden in die eingeschachtelte Sequenz zu kopieren.
Nach der Abarbeitung erfolgt ein Kopieren in die umgekehrte Richtung.

Eine Sequenzschachtelung gilt als \emph{eine} Operation in der umgebenden Sequenz. Solange die Zuordnung von "`exportierten"' Namen der
eingeschaltelten Sequenz zu Registern der umgebenden Sequenz korrekt ist (es wird kein Register verwendet, das bereits beschrieben wurde), bleiben die SSA-Bedingungen erfüllt.

\paragraph{Verzweigung:} Eine auf der Sequenzschachtelung basierende Operation. Eingaben sind zwei Blöcke (ein ``if''- und ein ``else''-Block) sowie ein Register vom
Typ Boolean mit dem Wert der Bedingung. Ist dieser "`wahr"', wird der ``if''-Block ausgeführt, sonst der ``else''-Block. Es müssen immer beide Blöcke
gegeben werden, Blöcke können aber leer sein.
%Soll ein Register in einer Verzweigung beschrieben werden, so muss dies immer in \emph{beiden} Blöcken geschehen, da ansonsten je nach Ausführungspfad ein
%Register undefinierte Wert

Ein Register kann in beiden Blöcken beschrieben werden (z.B. wenn im Quellcode eine Variable von einer Bedingung abhängig unterschiedliche Werte zugewiesen wurden).
Eine Verzweigung gilt als \emph{eine} Operation in der umgebenden Sequenz. D.h. auch wenn ein Register in beiden Blöcken beschrieben wird wird es,
von der umgebenden Sequenz aus gesehen, bloß von einer Operation beschrieben (eben der Verzweigung). Damit bleiben die SSA-Bedingungen erfüllt,
ohne dass ein Einsatz der $\phi$-Funktion nötig ist.
\\\hspace*{1cm}$\mathrm{if}\ s\ \mathrm{then}\ \mathit{Block}\ \mathrm{else}\ \mathit{Block}$

%Um die SSA-Bedingungen zu erfüllen, aber

\begin{figure}[h]
   \centering
  \includegraphics{ir_seq_branch}
  \caption{Schema einer Verzweigungsoperation.}
  \small\includegraphics[height=10pt]{ir_seq_torquoise_arrow} symbolisiert die Registerzuordnungen aus Abb.~\ref{fig:ir_seq_block_nest}.
  \label{fig:ir_seq_branch}
\end{figure}

\paragraph{While-Schleife:} Eine auf der Sequenzschachtelung basierende Operation. Eingaben sind ein Block sowie zwei Register vom
Typ Boolean, jeweils mit einem Wert der Bedingung: das erste Register enthält die Bedingung \emph{vor} der ersten Ausführung des Blockes,
das zweite Register die Bedingung \emph{nach} einer Ausführung des Blockes.

Werte, die sich von Schleifendurchlauf zu Schleifendurchlauf ändern, werden ähnlich behandelt: es muss jedem solchen Wert ein lokales
Register im Schleifenkörper zugeordnet werden. Die Schleifenoperation selber erhält eine Abbildung von einem Paar "`externer"' Register
(Wert vor dem ersten Durchlauf sowie Wert nach dem ersten Durchlauf) zu den lokalen Registern als weitere Eingabe. Durch die Verwendung eines
Paares von Eingaben wird die Verwendung der $\phi$-Funktion vermieden.

Ein Register kann in mehreren Schleifendurchläufen beschrieben werden.
Eine Schleife gilt als \emph{eine} Operation in der umgebenden Sequenz. D.h. auch ein mehrmals beschriebenes Register wird,
von der umgebenden Sequenz aus gesehen, bloß von einer Operation beschrieben (eben der Schleife).
Damit bleiben die SSA-Bedingungen erfüllt, und ein Einsatz der $\phi$-Funktion ist weiterhin nicht nötig.

Es gibt keine spezielle Operation für \texttt{for}-Schleifen, diese werden auf \texttt{while}-Schleifen abgebildet.
\\\hspace*{1cm}$\mathrm{while}\ s\ \mathrm{do}\ \mathit{Block}$

\paragraph{Funktionsaufruf:} Diese Operation nimmt einen Funktionsbezeichner, eine Liste Eingabe-Register, eine Liste Ausgabe-Register
und eventuell ein Zielregister für den Rückgabewert entgegen. Die Eingaberegister werden der Position nach auf die Funktionsparameter abgebildet.

Der "`Bezeichner"' ist eine prinzipiell arbiträre Zeichenkette, die die Funktion bezeichnet. Dem Code-Generator muss
vorher eine Funktionsbeschreibung übergeben worden sein, die durch den Bezeichner identifiziert werden kann.
\\\hspace*{1cm}$d \gets \mathrm{Funktion}\ (s, \dots)$
\\\hspace*{1cm}$\mathrm{Funktion}\ (s, \dots)$

\paragraph{Funktionsrücksprung:} Damit wird die Funktion verlassen. Hat die Funktion einen Rückgabewert, so wird als Parameter ein Register
erwartet, welches den Rückgabewert der Funktion enthält.
\\\hspace*{1cm}$\mathrm{return}\ s$
\\\hspace*{1cm}$\mathrm{return}$

\paragraph{Eingebaute Funktion:} Diese Operation sammelt den Zugriff auf eigebaute Funktionen (siehe~\ref{builtins})
und arbeitet analog zu Funktionsaufrufen. Es wird eine Konstante, welche die Funktion identifiziert, eine Liste Eingabe-Register 
und ein Zielregister für den Rückgabewert entgegengenommen. Die Eingaberegister werden wieder der Position nach auf die Funktionsparameter abgebildet.
\\\hspace*{1cm}$d \gets \mathrm{pow}(s, t)$
\\\hspace*{1cm}$d \gets s \cdot t$
\\\hspace*{1cm}$\phantom{d \gets}\vdots$

%$\phi$-Funktion: diese konkrete Zwischenrepräsentation eines compilierten Programmes enthält nicht die bei SSAs wesentliche $\phi$-Funktion.

\subsection{Code-Generator}

Der \emph{Code-Generator} übersetzt ein in der Zwischenrepräsentation vorliegendes Programm in eine \emph{Zieldarstellung}.
Diese "`Darstellung"' kann wieder eine Hochsprache sein, prinzipiell kann ein Code-Generator aber auch Assembler-Quelltext oder eine
Binärcodierung ausgeben.

\subsubsection{Eingaben und Aufgaben}

Der \emph{Code-Generator} erhält als Eingabe eine Liste von Funktionsbeschreibungen.
Eine Funktionsbeschreibung besteht aus dem eindeutigen Bezeichner, einer Liste von Parametern (getrennt nach Ein- und Ausgabeparametern)
und einer Sequenz mit den eigentlichen Operationen. Eine Funktion ist als "`Eintrittsfunktion"' markiert.

\begin{figure}[h]
   \centering
  \includegraphics{ir_program}
  \caption{Zusammensetzung eines Programms in der Zwischenrepräsentation}
  \label{fig:ir_program}
\end{figure}

Die Aufgaben des Code-Generators bestehen aus:
\begin{itemize}
\item Nötige Umformungen für die Zieldarstellung -- z.B. Schleifen ausrollen oder ``inlining'' von Funktionen.
\item Übertragung der Funktionsbeschreibungen in eine entsprechende Deklaration in der Zieldarstellung.
\item Übersetzung der Sequenzoperationen in die Zieldarstellung. 
\item Dabei Ressourcenallokation, wenn nötig (z.B. begrenzte Registerzahl in der Zieldarstellung).
\item Generierung von "`Schnittstellen-Anweisungen"' wie z.B. bei der Übergabe von Parametern an Funktionen
oder die Behandlung von Werten "`vor dem ersten Durchlauf, nach dem ersten Durchlauf"' wie sie bei Schleifen
auftreten.
\end{itemize}

\subsubsection{Generator für Cg}

In der vorliegenden Implementierung wurde als Zieldarstellung die Sprache Cg~(\cite{cgpaper}, \cite{cg_home}) gewählt.

Cg als Hochsprache kennt selbst Konstrukte wie Funktionen und Schleifen. Umformungen durch den Codegenerator
sind also nicht nötig.

Jede Funktion wird also direkt auf eine Cg-Funktion abgebildet.

Jedem Register der Zwischenrepräsentation wird eine Variable zugeordnet -- eine Registerallokation ist unnötig, diese wird später vom Cg-Compiler selbst vorgenommen.
"`Einfache"' Sequenzoperation (arithmetische Operationen u.ä.) lassen sich trivialerweise auf ein einzelnes Statement in Cg übertragen. 
Weiterhin werden die meisten eingebauten Funktionen und Attribute direkt von Cg unterstützt (Ausnahme ist das Matrix-Attribut \texttt{inverted}).

Kompliziertere Operationen -- Verzweigungen, Schleifen, Funktionsaufrufe -- resultieren in mehreren Statements, obwohl es sich bei dem
zusätzlichen "`Aufwand"' meist nur um Zuweisungen zwischen Variablen handelt, wie z.B. die Auswahl des Bedingungsregisters basierend zwischen
den Wert vor und nach dem ersten Schleifendurchlauf.

Die spezifizierte Sprache unterstützt Zeichenketten aus Unicode-Buchstaben und -Ziffern als Bezeichner;
Cg nur eine Untermenge von ASCII. Für die Ausgabe als Cg-Code werden Zeichen ausserhalb von ASCII in eine Darstellung in der von Cg akzeptieren
Zeichenmenge umgewandelt\footnote{Als Kodierung wurde Punycode~(\cite{rfc3492}) gewählt da dies die aus ASCII bestehenden Teile eines Bezeichners
gut lesbar lässt.}.

% Original-Schnipsel und Generator-Output

\section{Ausblick}

% AST: nützlich, wenn FEs für anderen Sprachen, oder komplexer (Strukturen)

\cleardoublepage
\appendix
\bibliography{thesis_de}
\addcontentsline{toc}{section}{Literatur}

\end{document}
