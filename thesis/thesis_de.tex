\documentclass[twoside,a4paper,fleqn,12pt]{article}
\usepackage{fancyhdr,a4wide,graphicx}
\usepackage[paper=a4paper,left=20mm,right=20mm,top=25mm,bottom=25mm]{geometry}
\pagestyle{fancy}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
%\usepackage[]{amsfonts}
\usepackage{amsmath}
\usepackage{color}
\usepackage{colortbl}
%\usepackage{mathptmx}
\usepackage[bitstream-charter]{mathdesign}
\usepackage{charter}
\usepackage{helvet}
\usepackage{courier}
\usepackage{verbatim}
\usepackage{sectsty}
\usepackage{listings}
\usepackage{scalefnt}
\usepackage{setspace}
\usepackage{ngerman}

\definecolor{darkred}{rgb}{.5,0,0}
\definecolor{darkblue}{rgb}{0,0,.5}
\usepackage[plainpages=false,pdfpagelabels,colorlinks=true,urlcolor=darkblue,pagecolor=darkred,citecolor=darkred,linkcolor=darkred]{hyperref}
%\newcommand\url[1]{\texttt{#1}}

\lstset{basicstyle=\ttfamily\small,lineskip=-0.5em}

% define the title
\author{Frank Richter 68278\\frank.richter@gmail.com}
\title{\usefont{OT1}{phv}{b}{n}\selectfont Entwicklung eines Compilers für eine auf Cg basierende Sprache zur Programmierung von Graphikkarten \normalfont}
\date{\today}

\begin{document}

\newcommand\btxandlong{und}
\newcommand\btxandshort{u}
\newcommand\Btxinlong{In}
\newcommand\Btxinshort{I}
\newcommand\btxpageslong{Seiten}
\newcommand\btxetalshort{et al}
\newcommand\btxeditionlong{Auflage}
\bibliographystyle{mystyle}

% Zeilenabstand 1.5
\renewcommand{\baselinestretch}{1.50}\normalsize

% Helvetica für Section-Titel
\allsectionsfont{\usefont{OT1}{phv}{b}{n}\selectfont}

% Different font in captions
\newcommand{\captionstyle}{\small\centering}

\makeatletter  % Allow the use of @ in command names
\long\def\@makecaption#1#2{%
  \vskip\abovecaptionskip
  \sbox\@tempboxa{{\captionstyle #1: #2}}%
  \ifdim \wd\@tempboxa >\hsize
    {\captionstyle #1: #2\par}
  \else
    \hbox to\hsize{\hfil\box\@tempboxa\hfil}%
  \fi
  \vskip\belowcaptionskip}
\makeatother   % Cancel the effect of \makeatletter

% Fussnoten: alle Zeilen einrücken
\makeatletter
\newlength{\myFootnoteWidth}
\newlength{\myFootnoteLabel}
\setlength{\myFootnoteLabel}{1.2em}%  <-- can be changed to any valid value
\renewcommand{\@makefntext}[1]{%
  \setlength{\myFootnoteWidth}{\columnwidth}%
  \addtolength{\myFootnoteWidth}{-\myFootnoteLabel}%
  \noindent\makebox[\myFootnoteLabel][r]{\@makefnmark\ }%
  \parbox[t]{\myFootnoteWidth}{#1}%
}
\makeatother

% ---------- normal title ---------- %
\titlepage
\maketitle
\thispagestyle{empty}
\newpage
\thispagestyle{empty}
\mbox{}

% ---------- Fancyheader ---------- %
\fancyhead[L]{}
\fancyhead[R]{}
\fancyfoot[C]{\today}
\fancyfoot[R]{\footnotesize \thepage{}}
\renewcommand{\headrulewidth}{0pt}
\setlength{\headheight}{24pt}

% generates the title


% ---------- table of contents ---------- %
\newpage
\pagenumbering{roman}
%\addcontentsline{toc}{section}{Inhaltsverzeichnis}
\pdfbookmark[1]{Inhaltsverzeichnis}{myPDFtocLabel}
\tableofcontents

\cleardoublepage
\pagenumbering{arabic}
\newcommand\todo[1]{\footnote{\textcolor{red}{TODO: #1}}}
\newcommand\fcite[1]{\footnote{\cite{#1}}}
\newcommand\fciteX[2]{\footnote{\cite{#1}, #2}}

\section{Zielstellung}

In der Echtzeit-3D-Graphik werden für 3D-Objekte überwiegend Dreiecksnetze\footnote{engl. ``triangle mesh'' und kürzer ``mesh''; siehe z.B. \cite{watt_de}}
verwendet. Dies spiegelt sich in dem Aufbau von 3D-Graphikprozessoren~("`GPU"') wie auch
den Programmierschnittstellen~(\cite{glspec4}, \cite{dx10}) wieder. Insbesondere bei der Programmierung der GPU müssen
separate Vertex- und Fragmentprogramme % Ref oder Erklärung was Vertex/Fragment
erstellt werden. Diese Aufteilung sowie die Definition der "`Schnittstelle"' zwischen den Verarbeitungseinheiten muss vom Programmierer manuell vorgenommen werden.

Ziel dieser Arbeit ist es, einen Compiler zu entwickeln, der die Aufteilung in Vertex- und Fragmentprogramme (und auch Schnittstellendefinition)
automatisch vornimmt,
ohne dass der Programmierer explizit angeben muss, auf welcher der Funktionseinheiten ein bestimmter Befehl ausgeführt wird.
Die zu compilierende Sprache wird in Abschnitt~\ref{langspec} spezifiziert. Die Compilerimplementierung wird in Abschnitt~\ref{implementation}
beschrieben.

% Nochmal Abschnitt mit kurzer Beschreibung wichtiger Konzepte? (meshes, Vertices vs Fragmente, ...)

\section{Sprachspezifikation}
\label{langspec}

\input{langspec}

\section{Implementierung}
\label{implementation}

\subsection{Compiler-Aufbau}
\begin{figure}[h]
   \centering
  \includegraphics{compiler_structure}
  \caption{Schematischer Aufbau des Compilers}
  \label{fig:structure}
\end{figure}

Der Aufbau entspricht grösstenteils dem, was für einen Compiler üblich ist: das \emph{Front-End} generiert nach Syntax- und Semantikanalyse
eine Repräsentation des Programms in einem \emph{Zwischencode}. Auf dieser Zwischenrepräsentation werden im "`Middle-End"' % Ref wo das gesagt wird, oder besseres Wort
Optimierungen vorgenommen. Im letzten Schritt wird im \emph{Back-End} aus der optimierten Zwischenrepräsentation der tatsächliche Zielcode generiert.

Besonderheit dieses Compilers ist der Schritt \emph{Auftrennung VP/FP}. Hier wird für jeden Befehl der Zwischenrepräsentation untersucht, mit
welcher Berechnungsfrequenz~(siehe \ref{Berechnungsfrequenz})\footnote{Es wird auch "`Meshfrequenz"' definiert, aber der Einfachheit halber
trennt diese Implementierung bloß in Vertex- und Fragmentfrequenz. Das Konzept ist jedoch auch auf weitere Frequenzen erweiterbar.}
jeder Befehl des Programms ausgeführt werden muss - mit anderen Worten,
es wird untersucht, welche Befehle auf der Vertex-Einheit oder der Fragment-Einheit ausgeführt werden müssen. Mit diesen Informationen kann
das Programm entsprechend in ein Vertex- und ein Fragment-Programm aufgeteilt werden. Da zur Laufzeit auch ein "`Übergeben"' von Ausgaben
des Vertexprogramms an Eingaben des Fragmentprogramms stattfindet wird auch eine den Vertex-Ausgaben zu Fragment-Eingaben
abbildende "`Schnittstelle"' generiert.

Die Programme werden vom Aufspalter in Zwischencode ausgegeben und können noch einmal optimiert werden. % Irgendein besonderer Vorteil?
Abschließend werden ein Fragment- und ein Vertexprogramm im gewünschten Zielcode ausgegeben\footnote{Diese Implementierung benutzt den
gleichen Generator für beide Programme, prinzipiell könnten diese jedoch mit verschiedenen Generatoren ausgegeben werden.}.

\subsection{Implementierungsdetails}

Als \emph{Programmiersprache}, in der die hier beschriebene Implementierung verfasst ist, wurde C++ gewählt.
Gründe dafür sind:
\begin{itemize}
\item Die Flexibilität der Sprache und deren reichhaltige Standardbibliothek,
\item hohe Portabilität (C++-Compiler sind für praktisch jede Plattform verfügbar),
\item eine reichhaltige Palette an von Dritten hergestellter Bibliotheken,
\item die einfache Bindbarkeit an andere Sprachen (direkt oder über eine C-kompatible Schnittstelle),
\item nicht zuletzt die Gewandheit des Autors dieser Arbeit in C++.
\end{itemize}
 
Um eine Wiederverwendung des Compilers zu vereinfachen wurde dieser im Wesentlichen als eine \emph{Bibliothek} realisiert;
eine "`Kommandozeilenversion"' des Compilers setzt auch auf diese Bibliothek auf.
 
Zur Sicherstellung der fortwährend korrekten Funktionsweise aller Module des Compilers wurden entwicklungsbegleitend 
jeweils \emph{Tests} der Module geschrieben (Black-Box und White-Box); Ausführen der Tests war regelmässiger Teil des Entwicklungsprozesses.
 
\subsection{Lexer}

Der \emph{Lexer} wandelt die als Byte-Strom vorliegende Eingabe in eine Folge von "`Tokens"'.
Ein Token ist eine der in Abschn.~\ref{Lexikalische Einheiten} aufgezählten lexikalischen Einheiten, ein bekanntes Symbol (Operatoren etc.) oder Schlüsselwort. 
Leerzeichen (``Whitespace'') und Kommentare werden bereits vom Lexer ignoriert (d.h. für diese werden keine Tokens produziert).

Der Lexer folgt einer typischen Implementierung wie sie z.B. in \cite{wirth_compiler} beschrieben ist. Auf einige beachtenswerte Aspekte
wird im folgenden eingegangen.

\paragraph{Eingabe.} Da die Spezifikation von Unicode als Eingabe ausgeht arbeitet, der Lexer entsprechend auf der Basis von Unicode-kodierten Zeichen.
Der Byte-Strom der Eingabe wird also in einem Schritt noch vor dem Lexer in einen "`Unicode-Strom"' umkodiert\footnote{Verwendet wird dazu die Bibliothek ICU,
\url{http://site.icu-project.org/}}.

\paragraph{Schlüsselwörter.} Erkennt der Lexer einen Bezeichner, wird auch geprüft, ob es sich um ein Schlüsselwort handelt. Ist dies der Fall
wird im Token eine dem Schlüsselwort eindeutig zugeordnete ID gespeichert.

Die erste Ausnahme allerdings bilden die Schlüsselwörter für Vektor- und Matrixtypen (Abschn.~\ref{Vektortypen}, \ref{Matrixtypen}). Diese entsprechen
jeweils dem Muster $\mathit{typ}\mathrm{N}$ bzw. $\mathit{typ}\mathrm{N}\mathit{x}\mathrm{M}$ (mit $N \in 1 \dots 4, M \in 1 \dots 4$).
Da eine eigene ID für jeden Vektor- oder Matrix insgesamt 20 weitere IDs pro Basis-Typ nach sich ziehen würde -- wobei später noch jeder ID wiederum
die ursprünglichen Werte für $N$ und $M$ nochmals zugeordnet
werden müssten -- wird generierten Token vermerkt, ob es sich um einen Vektor- oder Matrixtyp handelt.
Dazu überprüft der Lexer, ob ein Bezeichner den angegebenen Muster für Vektor- bzw. Matrixschlüsselwörtern entspricht.
Weiterhin werden bereits $N$ bzw. $M$ aus den Bezeichnern extrahiert und ebenfalls vermerkt.

\begin{figure}[h]
   \centering
  \lstinputlisting[language=C++]{snips/LexerToken.txt}
  \caption{Daten eines vom Lexer ausgegebenen Tokens}
  \label{fig:LexerToken}
\end{figure}

Die zweite Ausnahme bilden Attributnamen~(\ref{Attribute}) inklusive Swizzles~(\ref{Vektorattribute}). Diese sind teilweise recht allgemein, und
es erscheint wünschenswert, Bezeichner zuzulassen, die Attributnamen entsprechen -- z.B. ``length'', das auch ein Arrayattribut ist, und einbuchstabige
Bezeichner wie ``x'', ``y'' etc., welche auch Vektorattribute (Swizzles) sind. Syntaktisch gibt es keine Mehrdeutigkeiten zwischen Attributen und
anderen Bezeichnern -- ein Attribut kann \emph{nur} rechts eines \op{.} auftauchen, ein anderer Bezeichner dort nie.

Weiterhin schreibt die Spezifikation vor, dass zwei Bezeicher als identisch betrachtet werden, wenn sie kanonisch äquivalent im Sinne von Unicode sind.
Zu diesem Zweck werden alle Bezeichner vom Lexer nach einer von Unicode vorgegebenen Form normalisiert~(\cite{unicode}, Annex \#15).

\subsection{Parser}

Der \emph{Parser} (oder auch "`Scanner"') untersucht den vom Lexer gelieferten Strom von Tokens auf syntaktische Strukturen:
einerseits wird überprüft, ob der Token-Strom einem Wort der in der Sprachspezifikation gegebenen Sprache entspricht.
Andererseits werden wären der Überprüfung bereits syntaktische Elemente extrahiert um diese bei der semantischen Verarbeitung zu
verwenden.

Beispiel: Soll aus dem Token-Strom ein "`Ausdruck"'~(\ref{ausdruck}) gelesen werden, prüft der Parser, ob die Tokens der Regel eines gültigen
Ausdrucks folgen -- ist dies nicht der Fall, handelt es sich um einen \emph{Syntaxfehler}.
Gleichzeitig werden aber auch Informationen wie numerische Werte oder Bezeichner gespeichert, da diese für eine später folgende
\emph{semantische} Verarbeitung notwendig sind.

%- Lookahead: unendl.
%- Grammatik: kontextfrei, rechtsrekursiv

\subsubsection{Eigenschaften der Grammatik}

Die Grammatik ist kontextfrei. Die Regeln sind rechtsrekursiv.

\subsubsection{Aufbau des Parsers}
%- SemanticHandler

Der Parser ist handprogrammiert nach der Methode des rekursiven Abstiegs. % Ref Wirth?

Die semantische Verarbeitung wird an ein Interface vom Typ \verb+SemanticHandler+ übergeben.
Dieses Interface übernimmt die verschiedenen Aspekte der semantischen Verarbeitung, von der Verwaltung der
Symboltabellen bis zu einer geeigneten internen Repräsentation von Ausdrücken.

\verb+SemanticHandler+ besitzt Methoden, um syntaktische Elemente - wie Bezeichner und numerische Literale - in Objekte 
einzukapseln. Diese Objekte wiederum werden in der semantischen Verarbeitung anderer syntaktischer Elemente
zurück an das Interface übergeben.

Beispiel: Bei einem Ausdruck \verb+a * 2+ werden von \verb+SemanticHandler+ zunächst Repräsentationen für
\verb+a+ und \verb+2+ erfragt. Zurückgegeben werden Repräsentationen von "`Ausdrücken"'. Diese wiederum
dienen als Argumente, um eine Repräsentation einer Multiplikation zu erhalten. Diese letzte Repräsentation kann
dann überall dort verwendet werden, wo Ausdrücke erwartet werden: Zuweisungen, Funktionsparameter etc.

Vom \verb+SemanticHandler+ zum Parser gibt es auch einen "`Rückkanal"'. Dies ist nötig, da bei einigen
Konstrukten bekannt sein muss, ob ein Bezeichner eine Variable, eine Funktion oder einen Typ identifiziert.
(Beispiel: \verb+foo (1)+ - ist \verb+foo+ eine Funktion, so ist dies ein Funktionsaufruf; ist es ein Typ-Alias, so ist es
der Aufruf eines Typ-Konstruktors; ist \verb+foo+ eine Variable, so ist dies ein ungültiger Ausdruck.)

Die Fehlerbehandlung bei der syntaktischen wie auch semantischen Verarbeitung wird über \emph{Ausnahmen}
realisiert. Der Parser selbst fängt dabei Ausnahmen ab, um zu gewährleisten, dass möglichst viel eines
Programms verarbeitet wird, um möglichst viele potentielle Fehler aufzudecken: % Wirth
tritt z.B. eine Ausnahme während der Verarbeitung eines Block-Kommandos auf, setzt der Parser die
Verarbeitung nach dem nächsten Semikolon -- also mit dem nächsten Kommando -- fort (sofern kein Ende
des Blockes festgestellt wird).
Die abgefangen Ausnahmen werden jedoch nicht verworfen, sondern an ein Objekt zur Fehlerbehandlung
übergeben (um z.B. eine Ausgabe auf der Konsole vorzunehmen).

Die Idee hinter dem \verb+SemanticHandler+ ist eine möglichst vollständige Trennung zwischen syntaktischer
und semantischer Verarbeitung. Eine minimale Implementierung könnte intern eine (annähernde)
AST-Repräsentation generieren (nur "`annähernd"' da der Parser einige semantische Informationen über
Bezeichner benötigt). In der tatsächlichen Implementierung wird vom \verb+SemanticHandler+ allerdings 
gleich eine Umsetzung in die Zwischenrepräsentation vorgenommen (Beschreibung siehe Unten):
die Generierung eines ASTs wurde als Zwischenschritt wurde als unnötigen angesehen, da die Zwischenrepräsentation
wichtige semantische Eigenschaften (wie Typinformationen) erhält und sich die Verarbeitungsschritte "`Auftrennung"'
und "`Optimierung"' auf dieser besser vornehmen lassen.

\subsection{Zwischenrepräsentation}

% Abstrakte(s) Beispiel(e): Quellcode + resultierende Zw.rep.

Die \emph{Zwischenrepräsentation} basiert im Wesentlichen auf der SSA(Single Static Assignment)-Form.
% "Inspirationen": LLVM, Amme's SSA, GIMPLE/SIMPLE

Die Zwischenrepräsentation ist um "`Sequenzen"' herum organisiert. Eine Sequenz besteht aus "`Operationen"',
die auf "`Registern"' arbeiten. Register sind \emph{typisiert}, es gibt einen Registersatz für jeden verwendeten Typ.
Jedes Register besitzt ausserdem einen Namen; dieser wird aber nur verwendet, um generierten Code lesbarer zu machen.
Der wesentliche SSA-Aspekt ist, dass ein Register nur von \emph{einer} Operation der Sequenz beschrieben werden darf.

Register sind "`Sequenz-Lokal"', d.h. nur in \emph{einer} Sequenz sichtbar. Insbesondere können auf diese nicht implizit
aus verschachtelten Blöcke (wie sie auch bei Bedingungen oder Schleifen vorkommen) zugegriffen werden. 

Stattdessen werden zu eingeschachtelten Blöcken eine Zuordnung zwischen "`externen"' Registern und
lokalen Registern gespeichert. Semantisch findet am Anfang des Blockes ein Kopieren von externen Eingaberegistern
in lokale Register statt sowie am Ende ein zurückkopieren von lokalen Registern in die externen Ausgaberegister.
(Wie genau dies geschieht ist ein Implementierungsdetail, dass dem Generator obliegt.)

\paragraph{Funktionen:}
Eine Funktion der Zwischenrepräsentation besteht aus einem eindeutigem Bezeichner, einer Liste von Eingabeparametern,
einer Liste von Ausgabeparametern und einer Sequenz mit den eigentlichen Funktionsoperationen.

Jede Überladung muss einen eindeutigen Bezeichner erhalten; dieser wird aus dem ursprünglichen Bezeichner
sowie einer aus den Parametertypen generierten "`Signatur"' konstruiert.

Parameter werden mit einem Mechanismus, der der Behandlung "`externer"' Register in einem eingeschachteltem
Block ähnelt, übergeben. Die Parameterlisten enthalten zu jedem Parameter ein lokales Register, in dem die
Sequenz den Wert des Parameters "`erwartet"' bzw. den Wert eines Ausgabeparameters ablegt.
(Wie Parameter genau übergeben werden ist ein Implementierungsdetail, dass dem Generator obliegt.)

Ein Parameter, der gleichzeitig Ein- wie auch Ausgabeparameter ist, wird "`verdoppelt"', d.h. es wird daraus
ein nur-Eingabe- sowie auch ein nur-Ausgabe-Parameter generiert. Bei Funktionsaufrufen werden den beiden
Parametern auch entsprechend verschiedene Register zugeordnet.

\paragraph{Globale Variablen:}
Sequenzen sehen keine globalen Variablen vor. Diese werden nachgebildet, in dem in einer Funktion gelesene globale Variable
auf einen speziellen, "`versteckten"' Eingabeparameter abgebildet wird. Eine geschriebene globale Variable wird
auf einen speziellen Ausgabeparameter abgebildet. Nur in der Eintrittsfunktion werden globalen Variablen tatsächlich
"`eigene"' Register zugewiesen.

%Stattdessen werden zu eingeschachtelten Blöcken gespeichert, welche Register von dem Block gelesen oder
%beschrieben werden sollen

%Soll ein Register in einem eingeschachteltem Block gelesen oder beschrieben werden, 

\paragraph{Behandlung von Arrays:}
Arrays werden als "`ein"' Wert behandelt. D.h. eine Zuweisungsoperation kopiert immer ein ganzes Array.
Das Lesen einzelner Elemente geschieht mit Hilfe der Operation "`Extraktion eines Arrayelements"'.
Zum Schreiben eines Elements gibt es die Operation "`Änderung eines Arrayelements"'; diese kopiert alle Elemente
eines Arrays in das Zielarray \emph{außer} das Element eines gegebenen Indexes; im Zielarray wird dort der zu
schreibende Wert abgelegt.

\subsubsection{Sequenz-Operationen}

\paragraph{Zuweisungsoperation:} Kopiert Inhalt eines Registers in ein anderes.

\paragraph{Konstantenoperationen:} Diese weisen einem Register eine Bool'sche, Integer- (vorzeichenlos oder vorzeichenbehaftet) oder
Fließkommakonstante zu.

\paragraph{Typumwandlungsoperation:} Liest ein Register eines Typs und schreibt dessen Inhalt in ein Register eines anderen Typs, mit Umwandlung der Daten.
Kann zwischen Integer- (vorzeichenlos oder vorzeichenbehaftet) und Fließkommawerten umwandeln.

\paragraph{Arithmetische Operation:} Zwei Register des gleichen Typs -- Integer- (vorzeichenlos oder vorzeichenbehaftet) und Fließkommawerte --
werden durch eine arithmetische Operation verknüpft und das Ergebnis in ein weiteres Register geschrieben.

\paragraph{Vergleichsoperation:} Zwei Register des gleichen Typs -- Integer- (vorzeichenlos oder vorzeichenbehaftet) und Fließkommawerte --
werden miteinander verglichen (gleich, ungleich, größer, größer gleich, kleiner oder kleiner gleich) und das Ergebnis in ein Register vom Typ Boolean geschrieben.

\paragraph{Logische Operation:} Zwei Register des Typs Boolean werden durch logisch UND oder logisch ODER verknüpft und das Ergebnis in ein Register vom Typ Boolean geschrieben.

\paragraph{Unäre Operation:} Unäre Operationen sind Negation, Logisches NICHT und bitweise Invertierung.
Negation negiert den Wert eines Integer- (vorzeichenlos oder vorzeichenbehaftet) oder Fließkommaregisters und schreibt das Ergebnis in ein Register des selben Typs.
Logisches NICHT invertiert den Wert eines Registers vom Typ Boolean und schreibt das Ergebnis in ein Register des selben Typs.
Bitweise Invertiertung wird auf ein eines Integer- (vorzeichenlos oder vorzeichenbehaftet) Register angewendet und schreibt das Ergebnis in ein Register des selben Typs.

\paragraph{Vektor-Erstellung:} Nimmt als Eingabe ein bis vier Register, je nach der Komponentenanzahl des Ausgaberegisters; die Eingaberegister müssen alle
den Basistyp des Ausgaberegisters besitzen. Die Eingabe-Register werden der Reihe nach den Vektorkomponenten im Zielregister zugeordnet.

\paragraph{Extraktion von Vektorkomponente:} Nimmt als Eingabe ein Vektor-Register sowie eine Integer-Konstante $N$ im Bereich $0 \dots 3$ entgegen.
Aus dem übergebenen Vektor wird die Komponente Nummer $N$ extrahiert und in das Zielregister geschrieben.

\paragraph{Matrix-Erstellung:} Nimmt als Eingabe ein bis sechzehn Register, je nach den Dimensionen des Ausgaberegisters; die Eingaberegister müssen alle
den Basistyp des Ausgaberegisters besitzen. Die Eingabe-Register werden der Reihe nach den Elementen im Zielregister zugeordnet: zuerst das Element der ersten Spalte in der ersten Zeile,
als nächstes das Element der zweiten Spalte in der ersten Zeile, usw.

\paragraph{Array-Erstellung:} Nimmt als Eingabe eine Variable Anzahl von Registern, die Anzahl der Eingaberegister bestimmt die Länge des Arrays; die Eingaberegister müssen alle
den Basistyp des Ausgaberegisters besitzen. Die Eingabe-Register werden der Reihe nach den Array-Elementen im Zielregister zugeordnet.

\paragraph{Extraktion eines Arrayelements:} Nimmt als Eingabe ein Array-Register sowie ein Register mit einem vorzeichenlosen Integer. Aus dem Array wird das Register mit
Index des Integers extrahiert und in das Zielregister geschrieben, welches den Basistyp des Array-Registers besitzen muss.

\paragraph{Änderung eines Arrayelements:} Nimmt als Eingabe ein Array-Register, ein Register mit einem vorzeichenlosen Integer sowie ein Register
des Basistyps des Arrays entgegen. Aus dem Eingabearray werden alle Elemente \emph{außer} das Element eines gegebenen Indexes in das Array des Zielregisters kopiert;
dort wird stattdessen der Wert des dritten Registers abgelegt. Das Zielregister muss den Typ des Array-Registers besitzen.

\paragraph{Arraylänge:} Nimmt als Eingabe ein Array-Register entgegen. Schreibt in das Zielregister, welches vom Typ "`vorzeichenloser Integer"' sein muss,
die Anzahl der Elemente des Arrays.

\paragraph{Blockschachtelung:} Eine Operation, die auf eine weitere, eingeschachtelte Sequenz verweist, die beim Ausführen der Operation abgearbeitet wird.
Der eingeschachtelte "`Block"' enthält neben der Sequenz auch Listen von "`importierten"' und "`exportierten"' Namen.
Jedem Namen ist weiterhin ein Register in der eingeschaltelten Sequenz zugeordnet.
Beim Einfügen der Operation in eine Sequenz wird von dieser (die "`umgebende"' Sequenz) eine Zuordnung von "`importierten"' und "`exportierten"' Namen der
eingeschaltelten Sequenz zu Registern der umgebenden Sequenz vorgenommen. 
Diese Zuordnung wird benutzt, um vor der Abarbeitung der eingeschaltelten Sequenz Registerwerte von der umgebenden in die eingeschaltelte Sequenz zu kopieren;
nach der Abarbeitung erfolgt ein Kopieren in die umgekehrte Richtung.
Eine Blockschachtelung gilt als \emph{eine} Operation in der Sequenz. Solange die Zuordnung von "`exportierten"' Namen der
eingeschaltelten Sequenz zu Registern der umgebenden Sequenz korrekt ist (es wird kein Register verwendet, das bereits beschrieben wurde), bleiben die SSA-Bedingungen erfüllt.

\paragraph{Verzweigung:} Eine auf der Blockschachtelung basierende Operation. Parameter sind zwei Blöcke (ein ``if''- und ein ``else''-Block) sowie ein Register vom
Typ Boolean mit dem Wert der Bedingung. Ist der Wert dieses Registers "`wahr"', wird der ``if''-Block ausgeführt, sonst der ``else''-Block. Es müssen immer beide Blöcke
gegeben werden, ein Block kann aber leer sein.
%Soll ein Register in einer Verzweigung beschrieben werden, so muss dies immer in \emph{beiden} Blöcken geschehen, da ansonsten je nach Ausführungspfad ein
%Register undefinierte Wert
Ein Register kann in beiden Blöcken beschrieben werden (z.B. wenn im Quellcode eine Variable von einer Bedingung abhängig unterschiedliche Werte zugewiesen wurden).
Eine Verzweigung gilt als \emph{eine} Operation in der umgebenden Sequenz. D.h. auch wenn ein Register in beiden Blöcken beschrieben wird wird es,
von der umgebenden Sequenz aus gesehen, bloss von einer Operation beschrieben (eben der Verzweigung). Damit bleiben die SSA-Bedingungen erfüllt,
ohne dass ein Einsatz der $\phi$-Funktion nötig ist.

%Um die SSA-Bedingungen zu erfüllen, aber

\paragraph{While-Schleife:} Eine auf der Blockschachtelung basierende Operation. Parameter sind ein Block sowie zwei Register vom
Typ Boolean, jeweils mit dem Wert der Bedingung: das erste Register enthält die Bedingung \emph{vor} der ersten Ausführung des Blockes,
das zweite Register die Bedingung \emph{nach} einer Ausführung des Blockes.

Es gibt keine spezielle Operation für \texttt{for}-Schleifen, diese werden auf \texttt{while}-Schleifen abgebildet.

\paragraph{Funktionsaufruf:} Diese Operation nimmt einen Funktionsbezeichner, eine Liste Eingabe-Register, eine Liste Ausgabe-Register
und eventuell ein Zielregister für den Rückgabewert entgegen. Die Eingaberegister werden der Position nach auf die Funktionsparameter abgebildet.

Der "`Bezeichner"' ist eine prinzipiell arbiträre Zeichenkette, die die Funktion bezeichnet. Es wird davon ausgegangen, dass dem Code-Generator
vorher eine Funktionsbeschreibung übergeben wurde, die durch den Bezeichner identifiziert wird.

\paragraph{Funktionsrücksprung:} Damit wird die Funktion verlassen. Hat die Funktion einen Rückgabewert, so wird als Parameter ein Register
erwartet, welches den Rückgabewert der Funktion enthält.

\paragraph{Eingebaute Funktion:} Diese Operation sammelt den Zugriff auf eigebaute Funktionen (siehe~\ref{builtins})
und arbeitet analog zu Funktionsaufrufen. Es wird eine Konstante, welche die Funktion identifiziert, eine Liste Eingabe-Register 
und ein Zielregister für den Rückgabewert entgegengenommen. Die Eingaberegister werden wieder der Position nach auf die Funktionsparameter abgebildet.

%$\phi$-Funktion: diese konkrete Zwischenrepräsentation eines compilierten Programmes enthält nicht die bei SSAs wesentliche $\phi$-Funktion.

\subsection{Code-Generator}

Der \emph{Code-Generator} erhält eine Liste von Funktionsbeschreibungen; diese besteht aus dem eindeutigen Bezeichner,
einer Liste von Parametern (getrennt nach Ein- und Ausgabeparametern), und einer Sequenz mit den eigentlichen Operationen.

Für jede Funktion wird nun eine entsprechende Deklaration generiert und jede Sequenzoperation die entsprechenden Anweisung(en) in der Zielsprache übersetzt.
Weiterhin müssen den -- in der Anzahl unbegrenzten -- Registern der Zwischenrepräsentation tatsächliche "`Ressourcen"' zugewiesen werden
(Bsp.: ein Generator für eine Assemblersprache würde eine Registerallokation vornehmen).

In der vorliegenden Implementierung wurde als Zielsprache Cg gewählt.
Jedem Register der Zwischenrepräsentation wird eine Variable zugeordnet (eine Registerallokation ist unnötig da diese später vom Cg-Compiler vorgenommen wird).
"`Einfache"' Sequenzoperation (arithmetische Operationen u.ä.) lassen sich trivialerweise auf ein einzelnes Statement in Cg übertragen. 
Weiterhin werden die meisten eingebauten Funktionen direkt von Cg unterstützt. % Ausnahmen?
Kompliziertere Operationen -- Verzweigungen, Schleifen, Funktionsaufrufe -- resultieren in mehreren Statements, obwohl es sich bei dem
zusätzlichen "`Aufwand"' meist nur um Zuweisungen zwischen Variablen handelt (z.B. zur Auswahl des Bedingungsregisters).

% Spezialitäten bei einzelnen Sequenz-Op.?

\section{Ausblick}

\cleardoublepage
\appendix
\bibliography{thesis_de}
\addcontentsline{toc}{section}{Literatur}

\end{document}
